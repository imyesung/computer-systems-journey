## Basic Concepts
- **Recursion (재귀)**: 문제를 같은 형태의 더 작은 문제로 줄여 푸는 방법
    - Base case: 즉시 답을 아는 가장 작은 입력
    - Recursive case: 더 작은 입력으로 자기 자신 호출
    - Progress: 매번 입력 크기가 줄어듦
- **Recurrence (점화식)**: 수열 a₁, a₂, …에서 현재 항 aₙ을 인덱스가 더 작은 항들(예: aₙ₋₁, aₙ₋₂ 등)로 정의하는 수학적 식
- **Mathematical induction (수학적 귀납법)**: `Base(n=1)`와 `Step(가정 P(k) ⇒ 결론 P(k+1))`으로 모든 n에 대해 성질을 증명한다.


## Exercise 01

다음 수열의 n번째 항을 구하는 재귀 알고리즘을 작성하시오.

> $a_n = 5a_{n-1} + 3, \; a_1 = 0$

### Answer

```python
function A(n):
    if n == 1:      # base case
        return 0
    else:           # recursive case
        return 5 * A(n-1) + 3
```

### Trace

```python
A(1) = 0
A(2) = 5 * A(1) + 3 = 5 * 0 + 3 = 3
A(3) = 5 * A(2) + 3 = 5 * 3 + 3 = 18
A(4) = 5 * A(3) + 3 = 5 * 18 + 3 = 93
```


## Exercise 02
양의 정수 n에 대해 함수 `seq()`는 총 몇 회 호출되는가? 이때 최초의 호출 `seq(n)`도 포함하여 센다.

```python
seq(n):
    if (n = 1) return 1
    else return seq(n-1) + 3
```

### Answer
함수를 호출하는 총 횟수는 초기 호출을 포함하여 n회이다.
재귀 함수 `seq(n)`은 
- 기저 사례(base case)인 `seq(1)`에서 1을 반환
- n > 1일 때 `seq(n) = seq(n-1) + 3`로 정의한다.

총 호출 횟수 C(n)을 구하기 위해 점화식을 세우면, base case는 `C(1) = 1`, recursive case는 `C(n) = C(n-1) + 1`이 된다. 이는 현재 함수 호출 1회에 `seq(n-1)`을 호출하는 데 필요한 모든 호출 횟수 C(n-1)을 더한 것이다.

### Trace 

```python
C(1) = 1                       # seq(1)만 호출, 재귀 없음
C(2) = C(1) + 1 = 1 + 1 = 2    # seq(2), seq(1)
C(3) = C(2) + 1 = 2 + 1 = 3    # seq(3), seq(2), seq(1)
C(4) = C(3) + 1 = 3 + 1 = 4    # seq(4), seq(3), seq(2), seq(1)
```


## Exercise 03

다음 피보나치 수열을 구하는 재귀 알고리즘에서 5번째 피보나치 수를 구하는 `fib(5)`를 수행하면 함수 `fib()`는 총 몇 회 호출되는가? 이때 최초의 호출 `fib(5)`도 포함하여 센다. (이 문제는 `fib()`가 매우 불필요한 중복 호출이 심하다는 것을 느껴보게 하려고 출제하였다.)

```python
fib(n):
    if (n = 1 or n = 2) return 1
    else return fib(n-1) + fib(n-2)
```

### Answer

∴ 총 호출 = 9회

함수 호출 규칙
- n=1 또는 n=2면 그 자리에서 끝(더 호출 없음).
- n>2 경우, 그 자리에서 `fib(n-1)`과 `fib(n-2)`를 연산하기 위해 또 부름

`fib(5)` 호출 전개

```python
1. fib(5)
2.      fib(4)
3.          fib(3)
4.              fib(2)
5.              fib(1)
6.          fib(2)
7.      fib(3)
8.          fib(2)
9.          fib(1)
```

Dynamic programming에서는 불필요하게 같은 부분 문제를 여러 경로에서 반복해 푸는 상황을 **overlapping subproblems**라고 부른다. 이러한 중복은 cache를 활용하는 memoization 기법을 적용하여 제거하거나 최소화할 수 있다.


## Exercise 04

다음 하노이 탑 재귀 알고리즘에 대해 5개의 원반을 옮기고자 `move(5, a, b, c)`를 수행하면 함수 `move()`는 총 몇 회 호출되는가?
이때 최초의 호출 `move(5, a, b, c)`도 포함하여 센다.
원반을 옮기는 횟수와 `move()`가 호출되는 횟수는 같지 않다. (3번 문제처럼 피해 갈 수 있는데도 재귀를 통해 중복 호출을 하는 예도 있다. 이번 문제는 피해 갈 수 없지만 호출이 지수함수적으로 증가하는 하노이 탑 문제의 호출 횟수를 느껴보게 하려고 출제하였다.)

```python
move(n, a, b, c):
    if (n > 0)
        move(n-1, a, c, b)
        ① a에 있는 원반을 b로 옮긴다
        move(n-1, c, b, a)
```

### Answer

$M(n)$ = 원반을 옮기는 횟수 \
$C(n)$ = `move()`가 호출되는 횟수

$n > 0$인 하노이의 탑 재귀 알고리즘에서 $M(n)$과 $C(n)$의 정의는 비슷하게 느껴지지만 실제 값은 다르다.
$M(n) = 2^n-1$로 실제 원반이 이동한 횟수이고, \
$C(n) = 2^{n+1} - 1$ 이며, 원반이 실제 이동하지 않았으나, 함수를 호출한 경우도 포함한다. \
이는 $C(n)$에는 기저 조건인 `if (n > 0)`에 걸려 아무 이동 없이 바로 반환된 호출($n=0$인 호출)에서도 `move()`가 실행되기 때문이다.
```
    M(1) = 1, C(1) = 3
    M(2) = 3, C(2) = 7
    M(3) = 7, C(3) = 15
    M(4) = 15, C(4) = 31
    M(5) = 31, C(5) = 63
```

따라서 원반이 5개일 때 `move()`의 실행 횟수는
$C(5) = 63$ 이다.

∴ 63회

## Exercise 05 

4번 문제에서 함수 `move()`의 호출 함수 대신 ①의 원반을 옮기는 행위의 총 횟수를 세어보시오. 이 횟수와 `move()`의 호출 횟수는 어떤 관계가 있는지 생각해보시오.

### Answer

4번 문제 답안 내용과 같이 $M(n)$이 ①의 총 횟수이고, $C(n)$이 `move()`의 호출 횟수일 때의 관계를 살펴본다.

$M(n) = 2^n-1$이므로, $n = 5$ 일 때 $M(5) = 31$ 이다.\
이는 $C(4)$의 값과 같으며, $C(n)$은 항상 $M(n)$의 두 배에 $1$을 더한 값이다.

$M(n) = C(n-1)$ \
$C(n) = 2\,M(n) + 1$

$n > 0$ 일 때 두 관계식이 귀납적으로 성립하며, 이는 하노이의 탑 재귀 호출 구조가 높이 $n$의 **완전 이진 트리(complete binary tree)** 형태임을 의미한다.  


## Exercise 06
4번 문제에서 다음처럼 경계 조건이 빠진 채 알고리즘이 수행되면 어떻게 되는가?

```python
move(n, a, b, c):
    move(n-1, a, c, b)
    a에 있는 원반을 b로 옮긴다
    move(n-1, c, b, a)
```

### Answer 
기저 조건(base case)이 없으므로, $n < 0$ 가 되어도 재귀 호출이 멈추지 않고 계속 진행된다.


## Exercise 07

[알고리즘 2-6]의 선택 정렬 알고리즘에서 임의의 양의 정수 n에 대해 `selectionSort(A, n)`을 수행하면 함수 `selectionSort()`는 총 몇 회 수행되는가?
이때 최초의 호출 `selectionSort(A, n)`도 포함하여 센다.

```python
selectionSort(A[], n):  # 배열 A[0...n-1] 정렬한다
    if (n > 1)
        A[0...n-1] 중 가장 큰 수 A[k]를 찾는다
        A[k] <- A[n-1]  # A[k]와 A[n-1]의 값을 교환한다
        selectionSort(A, n-1)
```

### Answer

- 점화식 $C(n)=1+C(n-1)$ for $n\ge 2$
- Base case $C(1)=1$

재귀는 마지막 `selectionSort(A,1)`에서 종료되어 $n=0$ 호출은 없으므로, 호출 횟수는 총 $n$회이다.

∴ $C(n)=n$



## Exercise 08

다음의 재귀적 표현에서 `<T>`는 무엇을 표현한 것인가?

```
<T> = <숫자>| <T><숫자>
<숫자> = 0 | 1 | ... | 9
```

### Answer

`<T>`는 0~9로 이루어진, 길이가 1 이상인 숫자 문자열 전체를 뜻한다.
